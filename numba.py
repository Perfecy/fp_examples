import numpy as np
import numba as nb

@nb.vectorize(["int64(int64)"], target="parallel")
def square_if_even(x):
    """
    Если x чётное, вернуть x*x, иначе 0.
    Чистая функция.
    """
    if x % 2 == 0:
        return x*x
    else:
        return 0

def main_vectorized():
    data = np.arange(10_000_000, dtype=np.int64)
    # Вызов векторизованной функции: вернёт новый массив
    squared_evens = square_if_even(data)
    # Суммируем
    result = np.sum(squared_evens)
    print("Sum of squares of even numbers:", result)

if __name__ == "__main__":
    main_vectorized()




import numpy as np
from numba import njit

@njit
def sum_of_squares_evens(numbers):
    """
    Вычислить сумму квадратов всех чётных чисел в массиве 'numbers'.
    Функция "чистая": нет побочных эффектов, не изменяет внешний мир.
    """
    total = 0
    for n in numbers:
        if n % 2 == 0:
            total += n * n
    return total

def main():
    # Генерируем большой numpy-массив (вектор)
    arr = np.arange(10_000_000, dtype=np.int64)

    # Первый вызов "прогревает" Numba и компилирует функцию в машинный код
    result = sum_of_squares_evens(arr)
    print("Result:", result)

    # Второй вызов уже будет идти по скомпилированному коду, очень быстро
    result2 = sum_of_squares_evens(arr)
    print("Result again:", result2)

if __name__ == "__main__":
    main()



# В функциональном программировании принято минимизировать или полностью избегать побочных эффектов и мутаций. Это даёт ряд преимуществ при JIT-компиляции:

# Отсутствие мутаций. Компилятору проще понять, что нет «скрытых» изменений данных, значит можно агрессивнее оптимизировать, использовать регистры CPU, переставлять инструкции и т. д.

# Предсказуемый поток данных. Если результат зависит только от входных аргументов, то JIT-компилятор может, например, кэшировать промежуточные результаты или «расплющивать» циклы (loop unrolling).

# Параллелизм. При чистых функциях нет гонок за ресурсы, потому что данные не мутируются. Numba (при использовании parallel=True), может автоматически распараллелить цикл.

# Таким образом, чистота и функциональность делают JIT-оптимизации проще. В Python это не столь продвинуто, как в языках вроде Haskell или F#, но даже здесь можно получать значительные выгоды — особенно при работе с научными вычислениями и большими массивами (NumPy).